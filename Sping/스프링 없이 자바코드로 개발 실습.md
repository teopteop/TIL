## 스프링 없이 순수한 자바로 개발 실습


### 비즈니스 요구사항과 설계
### 회원
- 회원을 가입하고 조회할 수 있다.
- 회원은 일반과 VIP 두 가지 등급이 있다.
- 회원 데이터는 자체 DB를 구축할 수 있고, 외부 시스템과 연동할 수 있다.(미확정)

### interface => MemberService
- 회원가입
- 회원조회

### 구현체 => MemberServiceImpl

### 회원 저장소 => MemberServiceRepository
- MemoryMemberServiceRepository
- DbMemberServiceRepository


## 회원 도메인 개발
- Grade enum 파일 생성
  - Enum (열거형)이란?
    - enum 은 서로 연관된 상수(Constant)들의 집합을 정의하는 특별한 클래스
    - 미리 정해진 값들 중 하나만 선택하도록 강제할 때 유용한 데이터 타입
    - 값의 범위를 강제할 수 있다.
    - 가독성이 좋다. => 의미 있는 이름을 사용하여 코드 이해도를 높일 수 있다.
    - 클래스처럼 동작 가능하다. => 메서드 추가도 가능
  
- Member 클래스 파일 생성
  ```java
  private Long id;
  private String name;
  private Grade grade;
  ```
- 생성자 및 Getter and Setter 추가
- MemberRepository 인터페이스 생성
  - MemoryMemberRepository 구현체 생성
  ```java
  public class MemoryMemberRepository  implements MemberRepository {

    private static Map<Long, Member> store = new HashMap<>();
    // HashMap 저장소 역할

    @Override
    public void save(Member member) {
        store.put(member.getId(), member);
    }

    @Override
    public Member findById(Long memberId){
        return store.get(memberId);
    }
  }
  ```
- MemberService 인터페이스 생성
  ```java
  public interface MemberService {
    void join(Member member);
    Member findMember(Long memberId);
  }
  ```
- MemberServiceImpl 구현체 생성
  ```java
  public class MemberServiceImpl implements MemberService {

    private final MemberRepository memberRepository = new MemoryMemberRepository();

    @Override
    public void join(Member member) {
        memberRepository.save(member);
    }

    @Override
    public Member findMember(Long memberId) {
        return memberRepository.findById(memberId);;
    }
  }
  ```
  
## Junit 프레임워크를 이용한 테스트 진행
- test 폴더 안에 테스트용 member 패키지 생성
- MemberServiceTest 클래스 파일 생성
  ```java
  import org.assertj.core.api.Assertions;
  import org.junit.jupiter.api.Test;

  public class MemberServiceTest {

    MemberService memberService = new MemberServiceImpl();

    @Test
    void join(){
        //새로운 member 생성
        Member member = new Member(1L, "memberA", Grade.VIP);

        //member를 저장, 해당 id의 멤버를 findMember로 불러온다.
        memberService.join(member);
        Member findMember = memberService.findMember(1L);

        //두 객체(member)를 비교 
        Assertions.assertThat(member).isEqualTo(findMember);
    }
  }
  ```
- join을 실행하고 결과확인 => ok 

### 회원 도메인 설계의 문제점

- 이 코드의 설계상 문제점은?
- 다른 저장소로 변경할 때 OCP 원칙을 잘 준수할까?
- DIP를 잘 지키고 있을까?
- 의존관계가 인터페이스 뿐만 아니라 구현까지 모두 의존하는 문제점이 있음
  


## 주문과 할인 도메인 설계

### 주문과 할인 정책

- 회원은 상품을 주문할 수 있다.
- 회원 등급에 따라 할인 정책을 적용할 수 있다.
- 할인 정책은 모든 VIP는 1000원을 할인해주는 고정 금액 할인을 적용(추후 변경 가능)
- 할인 정책은 변경 가능성이 높다. 회사의 기본 할인 정책을 아직 정하지 못했고 최악의 경우 적용하지 않을 수 도 있다.

1. 주문 생성: 클라이언트는 주문 서비스에 주문 생성을 요청
2. 회원 조회: 할인을 위해서 회원 등급 확인이 필요 => 주문 서비스는 회원 저장소에서 회원을 조회해서 등급을 확인
3. 할인 적용: 주문 서비스는 회원 등급에 따른 할인 여부를 할인 정책에 위임
4. 주문 결과 반환: 주문 서비스는 할인 결과를 포함한 주문 결과를 반환한다.